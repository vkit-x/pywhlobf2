from typing import Optional
import logging
from pathlib import Path
import shutil
import re

import attrs
from cryptography.fernet import Fernet

logger = logging.getLogger(__name__)


@attrs.define
class SourceCodeInjectorConfig:
    enable: bool = True
    fernet_key: Optional[str] = ''


class SourceCodeInjector:

    def __init__(self, config: SourceCodeInjectorConfig):
        self.config = config

    @classmethod
    def encrypt(cls, fernet: Fernet, text: str):
        return f'(pywhlobf {fernet.encrypt(text.encode()).decode()})'

    @classmethod
    def decrept(cls, fernet: Fernet, text: str):
        return re.sub(
            # https://datatracker.ietf.org/doc/html/rfc3548.html#page-6
            r'\(pywhlobf ([a-zA-Z0-9=_-]+?)\)',
            lambda match: fernet.decrypt(match.group(1)).decode(),
            text,
        )

    @classmethod
    def inject_header(cls, code: str):
        header = '''
/* >>> Generated by pywhlobf SourceCodeInjector. */
#include <string>
#include <fstream>
#if __has_include(<filesystem>)
    #include <filesystem>
    namespace fs = std::filesystem;
#elif __has_include(<experimental/filesystem>)
    #include <experimental/filesystem>
    namespace fs = std::experimental::filesystem;
#else
#error cannot find the filesystem header.
#endif
/* <<< Generated by pywhlobf SourceCodeInjector. */

'''
        return header.lstrip() + code

    @classmethod
    def encrypt_and_inject_source_code(
        cls,
        py_file: Path,
        py_root_fd: Optional[Path],
        fernet: Fernet,
        code: str,
    ):
        # Encrypt source code.
        lines = ['const std::string encrypted_source_code =']
        for src_line in py_file.read_text().splitlines():
            encrypted_src_line = cls.encrypt(fernet, src_line)
            lines.append(f'"{encrypted_src_line}\\\\n"')
        # Adding empty string to handle empty file.
        lines.append('""')
        encrypted_src_code = '\n'.join(lines) + ';'

        # Encrypt file name or relative path.
        if py_root_fd:
            py_file_desc = str(py_file.relative_to(py_root_fd))
        else:
            py_file_desc = py_file.name
        encrypted_py_file_desc = cls.encrypt(fernet, py_file_desc)

        # Code snippet for saving encrypted source code.
        write_encrypted_src_code_to_tempfile_code = f'''
/* >>> Generated by pywhlobf SourceCodeInjector. */
static fs::path write_encrypted_src_code_to_temp_file() {{
    auto temp_fd = fs::temp_directory_path();
    auto temp_pywhlobf_fd = temp_fd / "pywhlobf";
    auto temp_file = temp_pywhlobf_fd / "{encrypted_py_file_desc}";

    if (fs::exists(temp_file)) {{
        // No need to update.
        return temp_file;
    }}

    // Make sure temp_fd exists.
    if (!fs::exists(temp_fd)) {{
        return temp_file;
    }}

    // Make sure temp_pywhlobf_fd exists.
    if (!fs::exists(temp_pywhlobf_fd)) {{
        if (!fs::create_directory(temp_pywhlobf_fd)) {{
            return temp_file;
        }}
    }}

    // Write the encrypted code to file.
    {encrypted_src_code}
    std::ofstream fout(temp_file);
    fout << encrypted_source_code;

    return temp_file;
}}
/* <<< Generated by pywhlobf SourceCodeInjector. */

'''
        write_encrypted_src_code_to_tempfile_code = \
            write_encrypted_src_code_to_tempfile_code.lstrip()

        # NOTE: This snippet will be injected into __PYX_ERR macro.
        # __PYX_ERR changes the variables in the scope, such as `__pyx_filename` variable.
        # In order to trace the temporary file, we will inject a `std::string __pyx_temp_file;`
        # statement after all appearances of `const char *__pyx_filename = NULL;`
        # and `static const char *__pyx_filename;`.
        pyx_mark_err_pos_code = '''
auto temp_file = write_encrypted_src_code_to_temp_file();
if (fs::exists(temp_file)) {
    __pyx_temp_file = temp_file.string();
    __pyx_filename = __pyx_temp_file.c_str();
}
/* Generated by pywhlobf SourceCodeInjector. */
'''
        # Flatten to one line.
        pyx_mark_err_pos_code = ' '.join(pyx_mark_err_pos_code.split())

        # Code injection.
        code = re.sub(
            r'(#define __PYX_MARK_ERR_POS.+?\\\s+\{.+?)\}',
            '\n'.join([
                write_encrypted_src_code_to_tempfile_code,
                r'\1' + pyx_mark_err_pos_code + '}',
            ]),
            code,
            flags=re.MULTILINE,
        )

        code = re.sub(
            r'^(static const char \*__pyx_filename;)',
            '\n'.join([
                r'\1',
                '/* Added by pywhlobf SourceCodeInjector. */',
                r'static std::string __pyx_temp_file;',
            ]),
            code,
            flags=re.MULTILINE,
        )

        code = re.sub(
            r'^(\s+)(const char \*__pyx_filename = NULL;)',
            '\n'.join([
                r'\1\2',
                r'\1' + '/* Added by pywhlobf SourceCodeInjector. */',
                r'\1std::string __pyx_temp_file;',
            ]),
            code,
            flags=re.MULTILINE,
        )

        code = re.sub(
            r'__Pyx_AddTraceback\(\"(.+?)\"',
            lambda match: (
                f'__Pyx_AddTraceback("{cls.encrypt(fernet, match.group(1))}" '
                '/* Changed by pywhlobf SourceCodeInjector. */'
            ),
            code,
            flags=re.MULTILINE,
        )

        code = re.sub(
            r'__Pyx_RaiseArgtupleInvalid\(\"(.+?)\"',
            lambda match: (
                f'__Pyx_RaiseArgtupleInvalid("{cls.encrypt(fernet, match.group(1))}" '
                '/* Changed by pywhlobf SourceCodeInjector. */'
            ),
            code,
            flags=re.MULTILINE,
        )

        return code

    def run(
        self,
        py_file: Path,
        cpp_file: Path,
        py_root_fd: Optional[Path] = None,
    ):
        if not self.config.enable:
            return False

        if not self.config.fernet_key:
            logger.warning('SourceCodeInjector is enabled but fernet_key is missing, abort.')
            return False

        # Backup for debugging.
        shutil.copyfile(cpp_file, cpp_file.with_suffix('.cpp.bak_before_source_code_injector'))

        fernet_key = self.config.fernet_key.encode()
        fernet = Fernet(fernet_key)

        # Change cpp file inplace.
        code = cpp_file.read_text()
        code = self.encrypt_and_inject_source_code(
            py_file=py_file,
            py_root_fd=py_root_fd,
            fernet=fernet,
            code=code,
        )
        code = self.inject_header(code)
        cpp_file.write_text(code)

        return True
